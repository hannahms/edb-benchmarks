---
- hosts: primary
  name: Reinit DB and enable CAMO
  gather_facts: true
  any_errors_fatal: true

  tasks:
    - name: Remove PGD nodes
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.part_node(node_name := '{{ item }}')
        db: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'
      loop:
        - pgd2
        - pgd3

    - name: Cleanup replication origin
      community.postgresql.postgresql_query:
        query: >-
          SELECT pg_replication_origin_drop('bdr_local_only_origin')
        db: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: DROP bdr extension
      community.postgresql.postgresql_query:
        query: >-
          DROP EXTENSION bdr CASCADE
        db: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: DROP database {{ pgd_cluster_database }}
      community.postgresql.postgresql_db:
        maintenance_db: postgres
        state: absent
        name: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        force: true
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Clear the previously saved postgresql.log
      ansible.builtin.file:
        path: "{{ pg_log }}/{{ pg_log_filename }}"
        state: absent
      become: true

    - name: Clear the previously saved bdr_init_physical.log on pgd2 and pgd3
      ansible.builtin.file:
        path: "{{ pg_log }}/bdr_init_physical.log"
        state: absent
      become: true
      when: inventory_hostname in ['pgd2', 'pgd3']

    - name: Run pg_ctl logrotate
      ansible.builtin.command:
        cmd: >-
          /usr/edb/as{{ pg_version }}/bin/pg_ctl logrotate -D {{ pg_data }}
      become: true
      become_user: "{{ pg_owner }}"

    - name: Restart Postgres on pgd1
      ansible.builtin.systemd:
        name: "edb-as-{{ pg_version }}"
        state: restarted
      become: true
      when: inventory_hostname == 'pgd1'

    - name: Stop Postgres on pgd2 and pgd3 [1]
      ansible.builtin.systemd:
        name: "edb-as-{{ pg_version }}"
        state: stopped
      become: true
      when: inventory_hostname in ['pgd2', 'pgd3']

    - name: Wait for port {{ pg_port }}
      ansible.builtin.wait_for:
        host: 0.0.0.0
        port: "{{ pg_port }}"
        state: started
      when: inventory_hostname == 'pgd1'

    - name: Create database {{ pgd_cluster_database }}
      ansible.builtin.command:
        cmd: >-
          /usr/edb/as{{ pg_version }}/bin/createdb -h {{ pg_login_unix_socket }} {{ pgd_cluster_database }}
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Restore database
      ansible.builtin.command:
        cmd: >-
          /usr/edb/as{{ pg_version }}/bin/pg_restore --if-exists --clean -j 4 {{ pg_data }}/backup
          -d {{ pgd_cluster_database }} -h {{ pg_login_unix_socket }} -p {{ pg_port }}
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Vacuum database
      ansible.builtin.command:
        cmd: >-
          /usr/edb/as{{ pg_version }}/bin/vacuumdb -d {{ pgd_cluster_database }}
          -h {{ pg_login_unix_socket }} -p {{ pg_port }} -F -j 4 -z
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Create bdr extension
      community.postgresql.postgresql_ext:
        name: bdr
        state: present
        db: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Create PGD node on pgd1
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.create_node(node_name := 'pgd1',
                                 local_dsn := 'host=pgd1 dbname={{ pgd_cluster_database }} port={{ pg_port }} user={{ pg_user }}',
                                 node_kind := 'data');
        db: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Create PGD group on pgd1
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.create_node_group(node_group_name := '{{ pgd_cluster_name }}',
                                       join_node_group := TRUE);
        db: "{{ pgd_cluster_database }}"
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Make pgd_replication_user a superuser
      community.postgresql.postgresql_user:
        name: "{{ pgd_replication_user }}"
        role_attr_flags: "replication,superuser"
        port: "{{ pg_port }}"
        db: "{{ pgd_cluster_database }}"
        state: present
        login_user: "{{ pg_owner }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Make pgd_cluster_database_owner a superuser
      community.postgresql.postgresql_user:
        name: "{{ pgd_cluster_database_owner }}"
        role_attr_flags: "replication,superuser"
        port: "{{ pg_port }}"
        db: "{{ pgd_cluster_database }}"
        state: present
        login_user: "{{ pg_owner }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Grant pgd_replication_user privileges
      community.postgresql.postgresql_privs:
        type: database
        state: present
        privs: CREATE
        roles: "{{ pgd_replication_user }}"
        db: "{{ pgd_cluster_database }}"
        port: "{{ pg_port }}"
        login_user: "{{ pg_owner }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Grant pgd_replication_user and pgd_cluster_database_owner membership to bdr_superuser
      community.postgresql.postgresql_membership:
        group: "bdr_superuser"
        target_role: "{{ item }}"
        db: "{{ pgd_cluster_database }}"
        state: present
        port: "{{ pg_port }}"
        login_user: "{{ pg_owner }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
      become: true
      become_user: "{{ pg_owner }}"
      loop:
        - "{{ pgd_replication_user }}"
        - "{{ pgd_cluster_database_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Store pgd_replication_user and pgd_cluster_database_owner password in .pgpass
      ansible.builtin.include_role:
        name: manage_dbserver
        tasks_from: manage_pgpass
      vars:
        pg_pgpass_values:
          - user: "{{ pgd_replication_user }}"
            password: "{{ pgd_replication_user_password }}"
            create: true
          - user: "{{ pgd_cluster_database_owner }}"
            password: "{{ pgd_cluster_database_owner_password }}"
            create: true

    - name: Cleaning up Postgres file systems
      ansible.builtin.shell: |
        rm -rf {{ pg_data }}
        rm -rf {{ pg_wal }}
        mkdir {{ pg_wal }}
        chown enterprisedb.enterprisedb {{ pg_wal }}
        # Required by bdr_init_physical
        chown enterprisedb.enterprisedb {{ pg_data | dirname }}
      become: true
      when: inventory_hostname in ['pgd2', 'pgd3']

    - name: Start stats collection for PGD initialization
      ansible.builtin.shell:
        cmd: ts sysstat -o {{ ts_pgd_init }}
      become: true
      async: 1
      poll: 0

    - name: Building pgd2 and pgd3 with bdr_init_physical
      ansible.builtin.shell: |
        PGAPPNAME={{ inventory_hostname }} /usr/edb/as{{ pg_version }}/bin/bdr_init_physical -D {{ pg_data }} \
                -l {{ pg_log }}/bdr_init_physical_camo.log \
                -n {{ inventory_hostname }} \
                --node-group-name {{ pgd_cluster_name }} \
                -d 'host=pgd1 port={{ pg_port }} dbname={{ pgd_cluster_database }} user={{ pgd_replication_user }}' \
                --local-dsn='host={{ inventory_hostname }} port={{ pg_port }} dbname={{ pgd_cluster_database }} user={{ pg_user }}'
      when: inventory_hostname in ['pgd2', 'pgd3']
      become: true
      become_user: "{{ pg_owner }}"

    - name: Stop system statistics collection for PGD initialization
      ansible.builtin.shell:
        cmd: ts sysstat -o {{ ts_pgd_init }} -s
      become: true

    # Need to use pg_ctl here instead of operating system service because
    # bdr_init_physical starts the database.
    - name: Stop Postgres on pgd2 and pgd3 [2]
      ansible.builtin.shell: |
        /usr/edb/as{{ pg_version }}/bin/pg_ctl -D {{ pg_data }} stop
      when: inventory_hostname in ['pgd2', 'pgd3']
      become: true
      become_user: "{{ pg_owner }}"

    - name: Updating PGWAL location
      ansible.builtin.shell: |
        rm -rf {{ pg_wal }}/*
        rsync -cavr {{ pg_data }}/pg_wal/* {{ pg_wal }}/.
        rm -rf {{ pg_data }}/pg_wal/
        ln -s {{ pg_wal }} {{ pg_data }}/pg_wal
      become: true
      when: inventory_hostname in ['pgd2', 'pgd3']

    - name: Starting Postgres on pgd2 and pgd3
      ansible.builtin.systemd:
        name: "edb-as-{{ pg_version }}"
        state: started
        enabled: true
      become: true
      when: inventory_hostname in ['pgd2', 'pgd3']

    - name: Set bdr.default_streaming_mode to 'off'
      community.postgresql.postgresql_query:
        query: >-
          ALTER SYSTEM SET bdr.default_streaming_mode TO 'off'
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        db: "{{ pgd_cluster_database }}"
        autocommit: true
      become: true
      become_user: "{{ pg_owner }}"

    - name: Set max_prepared_transactions to {{ max_prepared_transactions }}
      community.postgresql.postgresql_query:
        query: >-
          ALTER SYSTEM SET max_prepared_transactions TO {{ max_prepared_transactions }}
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        db: "{{ pgd_cluster_database }}"
        autocommit: true
      become: true
      become_user: "{{ pg_owner }}"

    - name: Reload Postgres configuration
      community.postgresql.postgresql_query:
        query: >-
          SELECT pg_reload_conf()
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        db: "{{ pgd_cluster_database }}"
        autocommit: true
      become: true
      become_user: "{{ pg_owner }}"

    # create camo commit scope
    - name: Create CAMO subgroup and have pgd1 join
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.create_node_group(node_group_name := '{{ camo_subgroup }}',
                                       parent_group_name := '{{ pgd_cluster_name }}',
                                       join_node_group := true);
        login_user: "{{ pg_user }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        port: "{{ pg_port }}"
        db: "{{ pgd_cluster_database }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd1'

    - name: Have pgd2 join CAMO subgroup
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.switch_node_group(node_group_name := '{{ camo_subgroup }}',
                                       wait_for_completion := true);
        login_user: "{{ pg_user }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        port: "{{ pg_port }}"
        db: "{{ pgd_cluster_database }}"
      become: true
      become_user: "{{ pg_owner }}"
      when: inventory_hostname == 'pgd2'

    - name: Add CAMO commit scope
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.add_commit_scope(commit_scope_name := 'camo_scope_1',
                                      origin_node_group := '{{ camo_subgroup }}',
                                      rule := '{{ camo_cs_rule }}',
                                      wait_for_ready := true);
        login_user: "{{ pg_user }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        port: "{{ pg_port }}"
        db: "{{ pgd_cluster_database }}"
      become: true
      become_user: "{{ pg_owner }}"
      throttle: 1
      when: inventory_hostname in ['pgd1', 'pgd2']

    - name: Set default commit scope
      community.postgresql.postgresql_query:
        query: >-
          SELECT bdr.alter_node_group_option(node_group_name := '{{ camo_subgroup }}',
                                             config_key := 'default_commit_scope',
                                             config_value := 'camo_scope_1');
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        autocommit: true
        db: "{{ pgd_cluster_database }}"
      become: true
      become_user: "{{ pg_owner }}"
      throttle: 1
      when: inventory_hostname in ['pgd1', 'pgd2']

    - name: Set local commit scope
      community.postgresql.postgresql_query:
        query: >-
          SET LOCAL bdr.commit_scope = 'camo_scope_1';
        login_user: "{{ pg_user }}"
        port: "{{ pg_port }}"
        login_unix_socket: "{{ pg_login_unix_socket }}"
        autocommit: true
        db: "{{ pgd_cluster_database }}"
      become: true
      become_user: "{{ pg_owner }}"
      throttle: 1
      when: inventory_hostname in ['pgd1', 'pgd2']

    - name: Restart the pg service
      ansible.builtin.systemd:
        name: "edb-as-{{ pg_version }}"
        state: restarted
      become: true
